#!/usr/bin/env python3
"""
This script converts an FSF file (as generated by the TCL possum:write procedure)
into a shell script that runs the various FSL/POSSUM commands.
It parses the FSF file (with lines of the form:
    set entries($w,KEY) "value"
)
and uses those parameters to compute derived values (e.g. new dimensions for fslcreatehd)
and then builds a shell script that:
  • makes the output directory,
  • creates a brain reference image,
  • registers the input object,
  • copies MRpar, slice-profile, motion and activation files,
  • builds the pulse sequence command, and
  • finally runs the possumX executable.
  
Note: This example “skips the check” portions and focuses on the FSF‐related exec commands.
"""

import argparse
import re
import math

def parse_fsf(fsf_filename):
    """
    Parse the FSF file to extract key–value pairs.
    Expected lines look like: 
        set entries($w,KEY) "value"
    Returns a dictionary mapping KEY -> value.
    """
    params = {}
    pattern = re.compile(r'set entries\(\$w,([^)]*)\)\s+"([^"]*)"')
    with open(fsf_filename, 'r') as f:
        for line in f:
            m = pattern.search(line)
            if m:
                key = m.group(1).strip()
                value = m.group(2).strip()
                params[key] = value
    return params

def compute_brain_ref(params):
    """
    Compute parameters for creating the brain reference image.
    This follows the logic in possum:procmakedir in the TCL code.
    
    Assumes the FSF file contains:
      inNx, inNy, inNz, inNt, vcX, vcY, vcZ,
      outsize_nx, outsize_ny, outsize_nz,
      outsize_dx, outsize_dy, outsize_dz,
      slcsampfactor, and slcselect.
    
    Returns a tuple:
      (newdim1, newdim2, newdim3, inNt, newpixdim1, newpixdim2, newpixdim3, pixdim4)
    """
    # Get original dimensions and voxel sizes
    inNx = float(params.get('inNx', '0'))
    inNy = float(params.get('inNy', '0'))
    inNz = float(params.get('inNz', '0'))
    inNt = params.get('inNt', '1')
    vcX = float(params.get('vcX', '1'))
    vcY = float(params.get('vcY', '1'))
    vcZ = float(params.get('vcZ', '1'))
    # Output sizes (if not provided, default to input dimensions)
    outsize_nx = int(params.get('outsize_nx', str(int(inNx))))
    outsize_ny = int(params.get('outsize_ny', str(int(inNy))))
    outsize_nz = int(params.get('outsize_nz', str(int(inNz))))
    outsize_dx = float(params.get('outsize_dx', '1'))
    outsize_dy = float(params.get('outsize_dy', '1'))
    outsize_dz = float(params.get('outsize_dz', '1'))
    slcsampfactor = float(params.get('slcsampfactor', '1'))
    # slcselect indicates the slice selection direction: x, y, or z.
    slcselect = params.get('slcselect', 'z')
    
    # Initially, use the original dimensions and voxel sizes.
    newdim1 = inNx
    newdim2 = inNy
    newdim3 = inNz
    newpixdim1 = vcX
    newpixdim2 = vcY
    newpixdim3 = vcZ

    # Adjust the dimension and voxel size in the slice direction.
    if slcselect == 'x':
        newpixdim1 = outsize_dx / slcsampfactor
        newdim1 = round(inNx * vcX / newpixdim1)
    elif slcselect == 'y':
        newpixdim2 = outsize_dy / slcsampfactor
        newdim2 = round(inNy * vcY / newpixdim2)
    elif slcselect == 'z':
        newpixdim3 = outsize_dz / slcsampfactor
        newdim3 = round(inNz * vcZ / newpixdim3)
    else:
        # Default to z if an unexpected value is given.
        newpixdim3 = outsize_dz / slcsampfactor
        newdim3 = round(inNz * vcZ / newpixdim3)
    
    # For the fourth dimension, we simply use the provided inNt value.
    pixdim4 = params.get('inNt', '1')
    return newdim1, newdim2, newdim3, inNt, newpixdim1, newpixdim2, newpixdim3, pixdim4

def generate_shell_commands(params):
    """
    Generate a list of shell command strings using the FSF parameters.
    The commands below mimic the exec commands in the TCL code,
    focusing on creating the brain reference, handling MR parameters,
    running the pulse command, and finally executing possumX.
    """
    # Use FSLDIR and POSSUMDIR if provided; otherwise use defaults.
    FSLDIR = params.get('FSLDIR', '/usr/local/fsl')
    POSSUMDIR = params.get('POSSUMDIR', FSLDIR)
    
    # Get key parameters (if a parameter isn’t set in the FSF file, defaults are provided)
    out = params.get('out', './simdir')
    obvol = params.get('obvol', '')
    mrpar = params.get('mrpar', '')
    slcprof = params.get('slcprof', '')
    mot = params.get('mot', '')
    userintmotfile = params.get('userintmotfile', '')
    act1 = params.get('act1', '')
    act2 = params.get('act2', '')
    seqtype = params.get('seqtype', 'epi')
    te = params.get('te', '0.03')
    tr = params.get('tr', '3')
    trslc = params.get('trslc', '0.12')
    numvol = params.get('numvol', '1')
    bw = params.get('bw', '100000')
    readgrad = params.get('readgrad', 'x')
    phencode = params.get('phencode', 'y')
    slcselect = params.get('slcselect', 'z')
    plus = params.get('plus', '+')
    maxG = params.get('maxG', '0.055')
    riseT = params.get('riseT', '0.00022')
    noise = params.get('noise_yn', '0')
    numproc = params.get('numproc', '1')
    segs = params.get('segs', '10000')
    cover = params.get('cover', '100')
    flipangle = params.get('flipangle', '90')
    
    # Compute the brain reference dimensions
    newdim1, newdim2, newdim3, inNt, newpixdim1, newpixdim2, newpixdim3, pixdim4 = compute_brain_ref(params)
    
    cmds = []
    
    # Create output directory
    cmds.append(f'mkdir -p {out}')
    
    # Brain reference creation: fslcreatehd and flirt
    cmds.append(f'{FSLDIR}/bin/fslcreatehd {newdim1} {newdim2} {newdim3} {inNt} {newpixdim1} {newpixdim2} {newpixdim3} {pixdim4} 0 0 0 16 {out}/brainref')
    cmds.append(f'{FSLDIR}/bin/flirt -in {obvol} -ref {out}/brainref -applyxfm -out {out}/brain')
    
    # Copy MR parameters, slice profile and motion files
    if mrpar:
        cmds.append(f'cp {mrpar} {out}/MRpar')
    if slcprof:
        cmds.append(f'cp {slcprof} {out}/slcprof')
    if mot:
        cmds.append(f'cp {mot} {out}/motion')
    if userintmotfile and userintmotfile != f'{FSLDIR}/data/possum/zeromotion':
        cmds.append(f'cp {userintmotfile} {out}/motion_pre')
    if act1:
        cmds.append(f'{FSLDIR}/bin/flirt -in {act1} -ref {out}/brainref -applyxfm -out {out}/T2')
    if act2:
        cmds.append(f'cp {act2} {out}/T2timecourse')
    
    # Compute additional values for pulse command:
    # Convert voxel dimensions from mm to meters (here we use 0.001 factor)
    dx = float(params.get('outsize_dx', '4.0')) * 0.001
    dy = float(params.get('outsize_dy', '4.0')) * 0.001
    dz = float(params.get('outsize_dz', '1.0')) * 0.001
    zs = float(params.get('zstart', '70')) * 0.001
    gap = float(params.get('gap', '0')) * 0.001

    # Build the pulse command (for non-custom pulse sequence)
    if seqtype.lower() in ['epi', 'ge']:
        pulse_cmd = (f'{POSSUMDIR}/bin/pulse -i {out}/brain -o {out}/pulse '
                     f'--seq={seqtype} --te={te} --tr={tr} ')
        if seqtype.lower() == 'epi':
            pulse_cmd += f'--trslc={trslc} '
        pulse_cmd += (f'--nx={params.get("outsize_nx", "64")} --ny={params.get("outsize_ny", "64")} '
                      f'--numslc={params.get("outsize_nz", "1")} --dx={dx} --dy={dy} --slcthk={dz} '
                      f'--numvol={numvol} --zstart={zs} --gap={gap} '
                      f'--bw={bw} --readdir={readgrad}{params.get("pluss", "")} '
                      f'--phasedir={phencode}{params.get("pluss", "")} '
                      f'--slcdir={slcselect}{plus} --maxG={maxG} --riset={riseT} '
                      f'--angle={flipangle} --cover={cover} -v')
        cmds.append(pulse_cmd + f' >> {out}/possum.log 2>&1')
    else:
        # For a custom pulse sequence, simply copy the provided files.
        pulse_basename = params.get('cuspulse', '')
        if pulse_basename:
            for ext in ["", ".info", ".posx", ".posy", ".posz"]:
                cmds.append(f'cp {pulse_basename}{ext} {out}/pulse{ext}')
    
    # Finally, the possumX command to run the simulation
    possumX_cmd = f'{POSSUMDIR}/bin/possumX {out} -n {numproc} -t {params.get("proctime", "0")} -s {segs} >> {out}/possum.log 2>&1'
    cmds.append(possumX_cmd)
    
    return cmds

def main():
    parser = argparse.ArgumentParser(description="Convert FSF file to shell script using converted Tcl exec commands.")
    parser.add_argument("fsf_file", help="Input FSF file (as generated by possum:write)")
    parser.add_argument("output_shell", help="Output shell script file")
    args = parser.parse_args()

    # Parse FSF file
    params = parse_fsf(args.fsf_file)
    
    # Generate the list of shell commands
    cmds = generate_shell_commands(params)
    
    # Write out the shell script
    with open(args.output_shell, 'w') as outf:
        outf.write("#!/bin/sh\n\n")
        for cmd in cmds:
            outf.write(cmd + "\n")
    print(f"Shell script written to {args.output_shell}")

if __name__ == "__main__":
    main()